# JavaScript异步编程
##### 主流的JavaScript环境都是以单线程模式去执行的
##### 原因：设计初衷是运行在浏览器端的脚本语言，为的是实现页面上的动态交互，实现动态交互的核心是DOM操作，这也决定了必须使用单线程模型，否则会出现很复杂的线程同步问题，若是采用多线程同时操控，浏览器无法明确以哪个线程为准，所以为了避免线程同步的问题，在最初JavaScript就被设置成单线程模型，也成为了JavaScript的核心之一
##### 单线程的优点：在同时只能执行一个任务，有多个任务就需要排队等候，更安全更简单
##### 单线程的缺点：若是某个任务特别耗时，会导致后续任务处于等待过程，会被拖延出现假死的情况
##### JavaScript将任务的执行模式分成了两种，同步模式(Synchronous)和异步模式(Asynchronous)
### 内容概要
+ 同步模式和异步模式
+ 事件循环与消息队列
+ 异步编程的几种方式
+ Promise 异步方案、宏任务 / 微任务
+ Generator 异步方案、Async / Await 语法糖
## 同步模式 Synchronous
##### 代码当中的任务依次执行，后一个任务需要等待前一个任务执行结束才能开始执行，执行顺序跟代码的编写顺序是一致的，排队执行
##### 当代码开始执行时会将当前执行代码压入栈中，等待其运行结束后移出栈，以此类推，若某个代码执行时间过长，后面的代码就会延迟，这种延迟叫做阻塞，对于用户来说页面就会变得卡顿，所以需要异步模式解决耗时操作






先创建了一个全局上下文，调用obj.func(40),创建了一个名为func的函数上下文，内部创建了num的变量，但此时用的是箭头函数，this指向了window，this.name=20+5=25，函数内部加的是内部由形参创建的num变量40+5=45，返回一个函数，因为上下文结束，把func函数上下文移出栈，再创建一个新的函数上下文，这个上下文是在全局上下文内的，相当于window.(obj.func(40))()，this指向window，this.name=window.name=25+4=29，最后一个num在函数内找不到，根据作用域链往函数定义位置往上找最近的num定义，是30，最后一个输出40






